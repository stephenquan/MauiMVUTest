using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;


namespace AppFramework.Mvvm;

[Generator]
public class BindablePropertyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //System.Diagnostics.Debugger.Launch();

        var properties = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is PropertyDeclarationSyntax prop && prop.AttributeLists.Count > 0,
                transform: static (ctx, _) =>
                {
                    var propertySyntax = (PropertyDeclarationSyntax)ctx.Node;
                    var propertySymbol = ctx.SemanticModel.GetDeclaredSymbol(propertySyntax) as IPropertySymbol;
                    if (propertySymbol is null)
                    {
                        return null;
                    }

                    bool hasAttribute = false;
                    foreach (var attr in propertySymbol.GetAttributes())
                    {
                        if (attr.AttributeClass?.Name == "AppFramework.Mvvm.BindablePropertyAttribute" ||
                            attr.AttributeClass?.ToDisplayString() == "AppFramework.Mvvm.BindablePropertyAttribute")
                        {
                            hasAttribute = true;
                            break;
                        }
                    }

                    return hasAttribute ? propertySymbol : null;
                })
            .Where(static symbol => symbol is not null);

        context.RegisterSourceOutput(properties, (spc, propertySymbol) =>
        {
            var classSymbol = propertySymbol!.ContainingType;
            var className = classSymbol.Name;
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var propertyName = propertySymbol.Name;
            var typeName = propertySymbol.Type.ToDisplayString();
            var bareTypeName = typeName.Replace("?", "");
            PropertyDeclarationSyntax propertySyntax = (propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax)!;
            var initializer = propertySyntax.Initializer;
            string initializerWithComma = (initializer is not null) ? $", {initializer.Value.ToString()}" : string.Empty;

            var source = $@"
using System.ComponentModel;

// <auto-generated/>
#pragma warning disable
#nullable enable

namespace {namespaceName};

//[{{GeneratedCodeAttribute}}]
partial class {className}
{{
    /// <summary>
    /// Bindable property for <see cref=""{propertyName}""/>.
    /// </summary>
    public static readonly BindableProperty {propertyName}Property
        = BindableProperty.Create(nameof({propertyName}), typeof({bareTypeName}), typeof({className}){initializerWithComma},
            propertyChanging: (b,o,n) =>
            {{
                (({className})b).On{propertyName}Changing(({typeName})n);
                (({className})b).On{propertyName}Changing(({typeName})o, ({typeName})n);
            }},
            propertyChanged: (b,o,n) =>
            {{
                (({className})b).On{propertyName}Changed(({typeName})n);
                (({className})b).On{propertyName}Changed(({typeName})o, ({typeName})n);
            }}
        );

    /// <inheritdoc />
    public partial {typeName} {propertyName}
    {{
        get => ({typeName})GetValue({propertyName}Property);
        set => SetValue({propertyName}Property, field = value);
    }}

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> is changing.</summary>
    /// <param name=""value"">The new property value being set.</param>
    /// <remarks>This method is invoked right before the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changing({typeName} value);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> is changing.</summary>
    /// <param name=""oldValue"">The previous property value that is being replaced.</param>
    /// <param name=""newValue"">The new property value being set.</param>
    /// <remarks>This method is invoked right before the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changing({typeName} oldValue, {typeName} newValue);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> just changed.</summary>
    /// <param name=""value"">The new property value that was set.</param>
    /// <remarks>This method is invoked right after the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changed({typeName} value);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> just changed.</summary>
    /// <param name=""oldValue"">The previous property value that was replaced.</param>
    /// <param name=""newValue"">The new property value that was set.</param>
    /// <remarks>This method is invoked right after the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changed({typeName} oldValue, {typeName} newValue);
}}
";
            spc.AddSource($"{className}_{propertyName}_BindableProperty.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }
}
