using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace AppFramework.Mvvm;

[Generator]
public class ObservablePropertyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var properties = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is PropertyDeclarationSyntax prop && prop.AttributeLists.Count > 0,
                transform: static (ctx, _) =>
                {
                    var propertySyntax = (PropertyDeclarationSyntax)ctx.Node;
                    var propertySymbol = ctx.SemanticModel.GetDeclaredSymbol(propertySyntax) as IPropertySymbol;
                    if (propertySymbol is null)
                    {
                        return null;
                    }

                    bool hasAttribute = false;
                    foreach (var attr in propertySymbol.GetAttributes())
                    {
                        if (attr.AttributeClass?.Name == "AppFramework.Mvvm.ObservablePropertyAttribute" ||
                            attr.AttributeClass?.ToDisplayString() == "AppFramework.Mvvm.ObservablePropertyAttribute")
                        {
                            hasAttribute = true;
                            break;
                        }
                    }

                    return hasAttribute ? propertySymbol : null;
                })
            .Where(static symbol => symbol is not null);

        context.RegisterSourceOutput(properties, (spc, propertySymbol) =>
        {
            var propertyAttributes = propertySymbol!.GetAttributes();
            var classSymbol = propertySymbol!.ContainingType;
            var className = classSymbol.Name;
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var propertyName = propertySymbol.Name;
            var typeName = propertySymbol.Type.ToDisplayString();
            var bareTypeName = typeName.Replace("?", "");
            PropertyDeclarationSyntax propertySyntax = (propertySymbol.DeclaringSyntaxReferences[0].GetSyntax() as PropertyDeclarationSyntax)!;
            var initializer = propertySyntax.Initializer;
            var initializerWithEquals = (initializer is not null) ? $" = {initializer.Value.ToString()}" : string.Empty;

            string getModifiers = string.Empty;
            string setModifiers = string.Empty;
            if (propertySyntax.AccessorList is not null)
            {
                foreach (var accessor in propertySyntax.AccessorList.Accessors)
                {
                    if (accessor.Kind() == SyntaxKind.GetAccessorDeclaration)
                    {
                        getModifiers = accessor.Modifiers.ToString();
                    }
                    else if (accessor.Kind() == SyntaxKind.SetAccessorDeclaration)
                    {
                        setModifiers = accessor.Modifiers.ToString();
                    }
                }
            }

            var source = $@"
using System.ComponentModel;

// <auto-generated/>
#pragma warning disable
#nullable enable

namespace {namespaceName};

/// <inheritdoc/>
partial class {className}
{{
    //{typeName} _{propertyName} {initializerWithEquals};

    /// <inheritdoc/>
    public partial {typeName} {propertyName}
    {{
        {getModifiers} get;
        {setModifiers} set
        {{
            if (!EqualityComparer<{typeName}>.Default.Equals(field, value))
            {{
                {typeName} oldValue = field;
                On{propertyName}Changing(value);
                On{propertyName}Changing(oldValue, value);
                field = value;
                On{propertyName}Changed(value);
                On{propertyName}Changed(oldValue, value);
                OnPropertyChanged(nameof({propertyName}));
            }}
        }}
    }}

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> is changing.</summary>
    /// <param name=""value"">The new property value being set.</param>
    /// <remarks>This method is invoked right before the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changing({typeName} value);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> is changing.</summary>
    /// <param name=""oldValue"">The previous property value that is being replaced.</param>
    /// <param name=""newValue"">The new property value being set.</param>
    /// <remarks>This method is invoked right before the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changing({typeName} oldValue, {typeName} newValue);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> just changed.</summary>
    /// <param name=""value"">The new property value that was set.</param>
    /// <remarks>This method is invoked right after the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changed({typeName} value);

    /// <summary>Executes the logic for when <see cref=""{propertyName}""/> just changed.</summary>
    /// <param name=""oldValue"">The previous property value that was replaced.</param>
    /// <param name=""newValue"">The new property value that was set.</param>
    /// <remarks>This method is invoked right after the value of <see cref=""{propertyName}""/> is changed.</remarks>
    partial void On{propertyName}Changed({typeName} oldValue, {typeName} newValue);
}}
";
            spc.AddSource($"{className}_{propertyName}_ObservableProperty.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }
}
